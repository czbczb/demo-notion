{"ast":null,"code":"import _extends from '@babel/runtime/helpers/esm/extends';\nimport removeAccents from 'remove-accents';\nvar rankings = {\n  CASE_SENSITIVE_EQUAL: 7,\n  EQUAL: 6,\n  STARTS_WITH: 5,\n  WORD_STARTS_WITH: 4,\n  CONTAINS: 3,\n  ACRONYM: 2,\n  MATCHES: 1,\n  NO_MATCH: 0\n};\nmatchSorter.rankings = rankings;\n\nvar defaultBaseSortFn = function defaultBaseSortFn(a, b) {\n  return String(a.rankedItem).localeCompare(b.rankedItem);\n};\n/**\n * Takes an array of items and a value and returns a new array with the items that match the given value\n * @param {Array} items - the items to sort\n * @param {String} value - the value to use for ranking\n * @param {Object} options - Some options to configure the sorter\n * @return {Array} - the new sorted array\n */\n\n\nfunction matchSorter(items, value, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      keys = _options.keys,\n      _options$threshold = _options.threshold,\n      threshold = _options$threshold === void 0 ? rankings.MATCHES : _options$threshold,\n      _options$baseSort = _options.baseSort,\n      baseSort = _options$baseSort === void 0 ? defaultBaseSortFn : _options$baseSort;\n  var matchedItems = items.reduce(reduceItemsToRanked, []);\n  return matchedItems.sort(function (a, b) {\n    return sortRankedItems(a, b, baseSort);\n  }).map(function (_ref) {\n    var item = _ref.item;\n    return item;\n  });\n\n  function reduceItemsToRanked(matches, item, index) {\n    var _getHighestRanking = getHighestRanking(item, keys, value, options),\n        rankedItem = _getHighestRanking.rankedItem,\n        rank = _getHighestRanking.rank,\n        keyIndex = _getHighestRanking.keyIndex,\n        _getHighestRanking$ke = _getHighestRanking.keyThreshold,\n        keyThreshold = _getHighestRanking$ke === void 0 ? threshold : _getHighestRanking$ke;\n\n    if (rank >= keyThreshold) {\n      matches.push({\n        rankedItem: rankedItem,\n        item: item,\n        rank: rank,\n        index: index,\n        keyIndex: keyIndex\n      });\n    }\n\n    return matches;\n  }\n}\n/**\n * Gets the highest ranking for value for the given item based on its values for the given keys\n * @param {*} item - the item to rank\n * @param {Array} keys - the keys to get values from the item for the ranking\n * @param {String} value - the value to rank against\n * @param {Object} options - options to control the ranking\n * @return {{rank: Number, keyIndex: Number, keyThreshold: Number}} - the highest ranking\n */\n\n\nfunction getHighestRanking(item, keys, value, options) {\n  if (!keys) {\n    return {\n      // ends up being duplicate of 'item' in matches but consistent\n      rankedItem: item,\n      rank: getMatchRanking(item, value, options),\n      keyIndex: -1,\n      keyThreshold: options.threshold\n    };\n  }\n\n  var valuesToRank = getAllValuesToRank(item, keys);\n  return valuesToRank.reduce(function (_ref2, _ref3, i) {\n    var rank = _ref2.rank,\n        rankedItem = _ref2.rankedItem,\n        keyIndex = _ref2.keyIndex,\n        keyThreshold = _ref2.keyThreshold;\n    var itemValue = _ref3.itemValue,\n        attributes = _ref3.attributes;\n    var newRank = getMatchRanking(itemValue, value, options);\n    var newRankedItem = rankedItem;\n    var minRanking = attributes.minRanking,\n        maxRanking = attributes.maxRanking,\n        threshold = attributes.threshold;\n\n    if (newRank < minRanking && newRank >= rankings.MATCHES) {\n      newRank = minRanking;\n    } else if (newRank > maxRanking) {\n      newRank = maxRanking;\n    }\n\n    if (newRank > rank) {\n      rank = newRank;\n      keyIndex = i;\n      keyThreshold = threshold;\n      newRankedItem = itemValue;\n    }\n\n    return {\n      rankedItem: newRankedItem,\n      rank: rank,\n      keyIndex: keyIndex,\n      keyThreshold: keyThreshold\n    };\n  }, {\n    rank: rankings.NO_MATCH,\n    keyIndex: -1,\n    keyThreshold: options.threshold\n  });\n}\n/**\n * Gives a rankings score based on how well the two strings match.\n * @param {String} testString - the string to test against\n * @param {String} stringToRank - the string to rank\n * @param {Object} options - options for the match (like keepDiacritics for comparison)\n * @returns {Number} the ranking for how well stringToRank matches testString\n */\n\n\nfunction getMatchRanking(testString, stringToRank, options) {\n  /* eslint complexity:[2, 12] */\n  testString = prepareValueForComparison(testString, options);\n  stringToRank = prepareValueForComparison(stringToRank, options); // too long\n\n  if (stringToRank.length > testString.length) {\n    return rankings.NO_MATCH;\n  } // case sensitive equals\n\n\n  if (testString === stringToRank) {\n    return rankings.CASE_SENSITIVE_EQUAL;\n  } // Lower casing before further comparison\n\n\n  testString = testString.toLowerCase();\n  stringToRank = stringToRank.toLowerCase(); // case insensitive equals\n\n  if (testString === stringToRank) {\n    return rankings.EQUAL;\n  } // starts with\n\n\n  if (testString.indexOf(stringToRank) === 0) {\n    return rankings.STARTS_WITH;\n  } // word starts with\n\n\n  if (testString.indexOf(\" \" + stringToRank) !== -1) {\n    return rankings.WORD_STARTS_WITH;\n  } // contains\n\n\n  if (testString.indexOf(stringToRank) !== -1) {\n    return rankings.CONTAINS;\n  } else if (stringToRank.length === 1) {\n    // If the only character in the given stringToRank\n    //   isn't even contained in the testString, then\n    //   it's definitely not a match.\n    return rankings.NO_MATCH;\n  } // acronym\n\n\n  if (getAcronym(testString).indexOf(stringToRank) !== -1) {\n    return rankings.ACRONYM;\n  } // will return a number between rankings.MATCHES and\n  // rankings.MATCHES + 1 depending  on how close of a match it is.\n\n\n  return getClosenessRanking(testString, stringToRank);\n}\n/**\n * Generates an acronym for a string.\n *\n * @param {String} string the string for which to produce the acronym\n * @returns {String} the acronym\n */\n\n\nfunction getAcronym(string) {\n  var acronym = '';\n  var wordsInString = string.split(' ');\n  wordsInString.forEach(function (wordInString) {\n    var splitByHyphenWords = wordInString.split('-');\n    splitByHyphenWords.forEach(function (splitByHyphenWord) {\n      acronym += splitByHyphenWord.substr(0, 1);\n    });\n  });\n  return acronym;\n}\n/**\n * Returns a score based on how spread apart the\n * characters from the stringToRank are within the testString.\n * A number close to rankings.MATCHES represents a loose match. A number close\n * to rankings.MATCHES + 1 represents a tighter match.\n * @param {String} testString - the string to test against\n * @param {String} stringToRank - the string to rank\n * @returns {Number} the number between rankings.MATCHES and\n * rankings.MATCHES + 1 for how well stringToRank matches testString\n */\n\n\nfunction getClosenessRanking(testString, stringToRank) {\n  var matchingInOrderCharCount = 0;\n  var charNumber = 0;\n\n  function findMatchingCharacter(matchChar, string, index) {\n    for (var j = index; j < string.length; j++) {\n      var stringChar = string[j];\n\n      if (stringChar === matchChar) {\n        matchingInOrderCharCount += 1;\n        return j + 1;\n      }\n    }\n\n    return -1;\n  }\n\n  function getRanking(spread) {\n    var inOrderPercentage = matchingInOrderCharCount / stringToRank.length;\n    var ranking = rankings.MATCHES + inOrderPercentage * (1 / spread);\n    return ranking;\n  }\n\n  var firstIndex = findMatchingCharacter(stringToRank[0], testString, 0);\n\n  if (firstIndex < 0) {\n    return rankings.NO_MATCH;\n  }\n\n  charNumber = firstIndex;\n\n  for (var i = 1; i < stringToRank.length; i++) {\n    var matchChar = stringToRank[i];\n    charNumber = findMatchingCharacter(matchChar, testString, charNumber);\n    var found = charNumber > -1;\n\n    if (!found) {\n      return rankings.NO_MATCH;\n    }\n  }\n\n  var spread = charNumber - firstIndex;\n  return getRanking(spread);\n}\n/**\n * Sorts items that have a rank, index, and keyIndex\n * @param {Object} a - the first item to sort\n * @param {Object} b - the second item to sort\n * @return {Number} -1 if a should come first, 1 if b should come first, 0 if equal\n */\n\n\nfunction sortRankedItems(a, b, baseSort) {\n  var aFirst = -1;\n  var bFirst = 1;\n  var aRank = a.rank,\n      aKeyIndex = a.keyIndex;\n  var bRank = b.rank,\n      bKeyIndex = b.keyIndex;\n\n  if (aRank === bRank) {\n    if (aKeyIndex === bKeyIndex) {\n      // use the base sort function as a tie-breaker\n      return baseSort(a, b);\n    } else {\n      return aKeyIndex < bKeyIndex ? aFirst : bFirst;\n    }\n  } else {\n    return aRank > bRank ? aFirst : bFirst;\n  }\n}\n/**\n * Prepares value for comparison by stringifying it, removing diacritics (if specified)\n * @param {String} value - the value to clean\n * @param {Object} options - {keepDiacritics: whether to remove diacritics}\n * @return {String} the prepared value\n */\n\n\nfunction prepareValueForComparison(value, _ref4) {\n  var keepDiacritics = _ref4.keepDiacritics;\n  value = \"\" + value; // toString\n\n  if (!keepDiacritics) {\n    value = removeAccents(value);\n  }\n\n  return value;\n}\n/**\n * Gets value for key in item at arbitrarily nested keypath\n * @param {Object} item - the item\n * @param {Object|Function} key - the potentially nested keypath or property callback\n * @return {Array} - an array containing the value(s) at the nested keypath\n */\n\n\nfunction getItemValues(item, key) {\n  if (typeof key === 'object') {\n    key = key.key;\n  }\n\n  var value;\n\n  if (typeof key === 'function') {\n    value = key(item); // eslint-disable-next-line no-negated-condition\n  } else if (key.indexOf('.') !== -1) {\n    // handle nested keys\n    value = key.split('.').reduce(function (itemObj, nestedKey) {\n      return itemObj ? itemObj[nestedKey] : null;\n    }, item);\n  } else {\n    value = item[key];\n  } // concat because `value` can be a string or an array\n  // eslint-disable-next-line\n\n\n  return value != null ? [].concat(value) : null;\n}\n/**\n * Gets all the values for the given keys in the given item and returns an array of those values\n * @param {Object} item - the item from which the values will be retrieved\n * @param {Array} keys - the keys to use to retrieve the values\n * @return {Array} objects with {itemValue, attributes}\n */\n\n\nfunction getAllValuesToRank(item, keys) {\n  return keys.reduce(function (allVals, key) {\n    var values = getItemValues(item, key);\n\n    if (values) {\n      values.forEach(function (itemValue) {\n        allVals.push({\n          itemValue: itemValue,\n          attributes: getKeyAttributes(key)\n        });\n      });\n    }\n\n    return allVals;\n  }, []);\n}\n/**\n * Gets all the attributes for the given key\n * @param {Object|String} key - the key from which the attributes will be retrieved\n * @return {Object} object containing the key's attributes\n */\n\n\nfunction getKeyAttributes(key) {\n  if (typeof key === 'string') {\n    key = {\n      key: key\n    };\n  }\n\n  return _extends({\n    maxRanking: Infinity,\n    minRanking: -Infinity\n  }, key);\n}\n\nexport { matchSorter, rankings };","map":{"version":3,"names":["_extends","removeAccents","rankings","CASE_SENSITIVE_EQUAL","EQUAL","STARTS_WITH","WORD_STARTS_WITH","CONTAINS","ACRONYM","MATCHES","NO_MATCH","matchSorter","defaultBaseSortFn","a","b","String","rankedItem","localeCompare","items","value","options","_options","keys","_options$threshold","threshold","_options$baseSort","baseSort","matchedItems","reduce","reduceItemsToRanked","sort","sortRankedItems","map","_ref","item","matches","index","_getHighestRanking","getHighestRanking","rank","keyIndex","_getHighestRanking$ke","keyThreshold","push","getMatchRanking","valuesToRank","getAllValuesToRank","_ref2","_ref3","i","itemValue","attributes","newRank","newRankedItem","minRanking","maxRanking","testString","stringToRank","prepareValueForComparison","length","toLowerCase","indexOf","getAcronym","getClosenessRanking","string","acronym","wordsInString","split","forEach","wordInString","splitByHyphenWords","splitByHyphenWord","substr","matchingInOrderCharCount","charNumber","findMatchingCharacter","matchChar","j","stringChar","getRanking","spread","inOrderPercentage","ranking","firstIndex","found","aFirst","bFirst","aRank","aKeyIndex","bRank","bKeyIndex","_ref4","keepDiacritics","getItemValues","key","itemObj","nestedKey","concat","allVals","values","getKeyAttributes","Infinity"],"sources":["/Users/mobvista/cui_workspace/notion/node_modules/match-sorter/dist/match-sorter.esm.js"],"sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\nimport removeAccents from 'remove-accents';\n\nvar rankings = {\n  CASE_SENSITIVE_EQUAL: 7,\n  EQUAL: 6,\n  STARTS_WITH: 5,\n  WORD_STARTS_WITH: 4,\n  CONTAINS: 3,\n  ACRONYM: 2,\n  MATCHES: 1,\n  NO_MATCH: 0\n};\nmatchSorter.rankings = rankings;\n\nvar defaultBaseSortFn = function (a, b) {\n  return String(a.rankedItem).localeCompare(b.rankedItem);\n};\n/**\n * Takes an array of items and a value and returns a new array with the items that match the given value\n * @param {Array} items - the items to sort\n * @param {String} value - the value to use for ranking\n * @param {Object} options - Some options to configure the sorter\n * @return {Array} - the new sorted array\n */\n\n\nfunction matchSorter(items, value, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      keys = _options.keys,\n      _options$threshold = _options.threshold,\n      threshold = _options$threshold === void 0 ? rankings.MATCHES : _options$threshold,\n      _options$baseSort = _options.baseSort,\n      baseSort = _options$baseSort === void 0 ? defaultBaseSortFn : _options$baseSort;\n  var matchedItems = items.reduce(reduceItemsToRanked, []);\n  return matchedItems.sort(function (a, b) {\n    return sortRankedItems(a, b, baseSort);\n  }).map(function (_ref) {\n    var item = _ref.item;\n    return item;\n  });\n\n  function reduceItemsToRanked(matches, item, index) {\n    var _getHighestRanking = getHighestRanking(item, keys, value, options),\n        rankedItem = _getHighestRanking.rankedItem,\n        rank = _getHighestRanking.rank,\n        keyIndex = _getHighestRanking.keyIndex,\n        _getHighestRanking$ke = _getHighestRanking.keyThreshold,\n        keyThreshold = _getHighestRanking$ke === void 0 ? threshold : _getHighestRanking$ke;\n\n    if (rank >= keyThreshold) {\n      matches.push({\n        rankedItem: rankedItem,\n        item: item,\n        rank: rank,\n        index: index,\n        keyIndex: keyIndex\n      });\n    }\n\n    return matches;\n  }\n}\n/**\n * Gets the highest ranking for value for the given item based on its values for the given keys\n * @param {*} item - the item to rank\n * @param {Array} keys - the keys to get values from the item for the ranking\n * @param {String} value - the value to rank against\n * @param {Object} options - options to control the ranking\n * @return {{rank: Number, keyIndex: Number, keyThreshold: Number}} - the highest ranking\n */\n\n\nfunction getHighestRanking(item, keys, value, options) {\n  if (!keys) {\n    return {\n      // ends up being duplicate of 'item' in matches but consistent\n      rankedItem: item,\n      rank: getMatchRanking(item, value, options),\n      keyIndex: -1,\n      keyThreshold: options.threshold\n    };\n  }\n\n  var valuesToRank = getAllValuesToRank(item, keys);\n  return valuesToRank.reduce(function (_ref2, _ref3, i) {\n    var rank = _ref2.rank,\n        rankedItem = _ref2.rankedItem,\n        keyIndex = _ref2.keyIndex,\n        keyThreshold = _ref2.keyThreshold;\n    var itemValue = _ref3.itemValue,\n        attributes = _ref3.attributes;\n    var newRank = getMatchRanking(itemValue, value, options);\n    var newRankedItem = rankedItem;\n    var minRanking = attributes.minRanking,\n        maxRanking = attributes.maxRanking,\n        threshold = attributes.threshold;\n\n    if (newRank < minRanking && newRank >= rankings.MATCHES) {\n      newRank = minRanking;\n    } else if (newRank > maxRanking) {\n      newRank = maxRanking;\n    }\n\n    if (newRank > rank) {\n      rank = newRank;\n      keyIndex = i;\n      keyThreshold = threshold;\n      newRankedItem = itemValue;\n    }\n\n    return {\n      rankedItem: newRankedItem,\n      rank: rank,\n      keyIndex: keyIndex,\n      keyThreshold: keyThreshold\n    };\n  }, {\n    rank: rankings.NO_MATCH,\n    keyIndex: -1,\n    keyThreshold: options.threshold\n  });\n}\n/**\n * Gives a rankings score based on how well the two strings match.\n * @param {String} testString - the string to test against\n * @param {String} stringToRank - the string to rank\n * @param {Object} options - options for the match (like keepDiacritics for comparison)\n * @returns {Number} the ranking for how well stringToRank matches testString\n */\n\n\nfunction getMatchRanking(testString, stringToRank, options) {\n  /* eslint complexity:[2, 12] */\n  testString = prepareValueForComparison(testString, options);\n  stringToRank = prepareValueForComparison(stringToRank, options); // too long\n\n  if (stringToRank.length > testString.length) {\n    return rankings.NO_MATCH;\n  } // case sensitive equals\n\n\n  if (testString === stringToRank) {\n    return rankings.CASE_SENSITIVE_EQUAL;\n  } // Lower casing before further comparison\n\n\n  testString = testString.toLowerCase();\n  stringToRank = stringToRank.toLowerCase(); // case insensitive equals\n\n  if (testString === stringToRank) {\n    return rankings.EQUAL;\n  } // starts with\n\n\n  if (testString.indexOf(stringToRank) === 0) {\n    return rankings.STARTS_WITH;\n  } // word starts with\n\n\n  if (testString.indexOf(\" \" + stringToRank) !== -1) {\n    return rankings.WORD_STARTS_WITH;\n  } // contains\n\n\n  if (testString.indexOf(stringToRank) !== -1) {\n    return rankings.CONTAINS;\n  } else if (stringToRank.length === 1) {\n    // If the only character in the given stringToRank\n    //   isn't even contained in the testString, then\n    //   it's definitely not a match.\n    return rankings.NO_MATCH;\n  } // acronym\n\n\n  if (getAcronym(testString).indexOf(stringToRank) !== -1) {\n    return rankings.ACRONYM;\n  } // will return a number between rankings.MATCHES and\n  // rankings.MATCHES + 1 depending  on how close of a match it is.\n\n\n  return getClosenessRanking(testString, stringToRank);\n}\n/**\n * Generates an acronym for a string.\n *\n * @param {String} string the string for which to produce the acronym\n * @returns {String} the acronym\n */\n\n\nfunction getAcronym(string) {\n  var acronym = '';\n  var wordsInString = string.split(' ');\n  wordsInString.forEach(function (wordInString) {\n    var splitByHyphenWords = wordInString.split('-');\n    splitByHyphenWords.forEach(function (splitByHyphenWord) {\n      acronym += splitByHyphenWord.substr(0, 1);\n    });\n  });\n  return acronym;\n}\n/**\n * Returns a score based on how spread apart the\n * characters from the stringToRank are within the testString.\n * A number close to rankings.MATCHES represents a loose match. A number close\n * to rankings.MATCHES + 1 represents a tighter match.\n * @param {String} testString - the string to test against\n * @param {String} stringToRank - the string to rank\n * @returns {Number} the number between rankings.MATCHES and\n * rankings.MATCHES + 1 for how well stringToRank matches testString\n */\n\n\nfunction getClosenessRanking(testString, stringToRank) {\n  var matchingInOrderCharCount = 0;\n  var charNumber = 0;\n\n  function findMatchingCharacter(matchChar, string, index) {\n    for (var j = index; j < string.length; j++) {\n      var stringChar = string[j];\n\n      if (stringChar === matchChar) {\n        matchingInOrderCharCount += 1;\n        return j + 1;\n      }\n    }\n\n    return -1;\n  }\n\n  function getRanking(spread) {\n    var inOrderPercentage = matchingInOrderCharCount / stringToRank.length;\n    var ranking = rankings.MATCHES + inOrderPercentage * (1 / spread);\n    return ranking;\n  }\n\n  var firstIndex = findMatchingCharacter(stringToRank[0], testString, 0);\n\n  if (firstIndex < 0) {\n    return rankings.NO_MATCH;\n  }\n\n  charNumber = firstIndex;\n\n  for (var i = 1; i < stringToRank.length; i++) {\n    var matchChar = stringToRank[i];\n    charNumber = findMatchingCharacter(matchChar, testString, charNumber);\n    var found = charNumber > -1;\n\n    if (!found) {\n      return rankings.NO_MATCH;\n    }\n  }\n\n  var spread = charNumber - firstIndex;\n  return getRanking(spread);\n}\n/**\n * Sorts items that have a rank, index, and keyIndex\n * @param {Object} a - the first item to sort\n * @param {Object} b - the second item to sort\n * @return {Number} -1 if a should come first, 1 if b should come first, 0 if equal\n */\n\n\nfunction sortRankedItems(a, b, baseSort) {\n  var aFirst = -1;\n  var bFirst = 1;\n  var aRank = a.rank,\n      aKeyIndex = a.keyIndex;\n  var bRank = b.rank,\n      bKeyIndex = b.keyIndex;\n\n  if (aRank === bRank) {\n    if (aKeyIndex === bKeyIndex) {\n      // use the base sort function as a tie-breaker\n      return baseSort(a, b);\n    } else {\n      return aKeyIndex < bKeyIndex ? aFirst : bFirst;\n    }\n  } else {\n    return aRank > bRank ? aFirst : bFirst;\n  }\n}\n/**\n * Prepares value for comparison by stringifying it, removing diacritics (if specified)\n * @param {String} value - the value to clean\n * @param {Object} options - {keepDiacritics: whether to remove diacritics}\n * @return {String} the prepared value\n */\n\n\nfunction prepareValueForComparison(value, _ref4) {\n  var keepDiacritics = _ref4.keepDiacritics;\n  value = \"\" + value; // toString\n\n  if (!keepDiacritics) {\n    value = removeAccents(value);\n  }\n\n  return value;\n}\n/**\n * Gets value for key in item at arbitrarily nested keypath\n * @param {Object} item - the item\n * @param {Object|Function} key - the potentially nested keypath or property callback\n * @return {Array} - an array containing the value(s) at the nested keypath\n */\n\n\nfunction getItemValues(item, key) {\n  if (typeof key === 'object') {\n    key = key.key;\n  }\n\n  var value;\n\n  if (typeof key === 'function') {\n    value = key(item); // eslint-disable-next-line no-negated-condition\n  } else if (key.indexOf('.') !== -1) {\n    // handle nested keys\n    value = key.split('.').reduce(function (itemObj, nestedKey) {\n      return itemObj ? itemObj[nestedKey] : null;\n    }, item);\n  } else {\n    value = item[key];\n  } // concat because `value` can be a string or an array\n  // eslint-disable-next-line\n\n\n  return value != null ? [].concat(value) : null;\n}\n/**\n * Gets all the values for the given keys in the given item and returns an array of those values\n * @param {Object} item - the item from which the values will be retrieved\n * @param {Array} keys - the keys to use to retrieve the values\n * @return {Array} objects with {itemValue, attributes}\n */\n\n\nfunction getAllValuesToRank(item, keys) {\n  return keys.reduce(function (allVals, key) {\n    var values = getItemValues(item, key);\n\n    if (values) {\n      values.forEach(function (itemValue) {\n        allVals.push({\n          itemValue: itemValue,\n          attributes: getKeyAttributes(key)\n        });\n      });\n    }\n\n    return allVals;\n  }, []);\n}\n/**\n * Gets all the attributes for the given key\n * @param {Object|String} key - the key from which the attributes will be retrieved\n * @return {Object} object containing the key's attributes\n */\n\n\nfunction getKeyAttributes(key) {\n  if (typeof key === 'string') {\n    key = {\n      key: key\n    };\n  }\n\n  return _extends({\n    maxRanking: Infinity,\n    minRanking: -Infinity\n  }, key);\n}\n\nexport { matchSorter, rankings };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}